# scripts/phased_recovery.py
"""
Phased recovery for UG Board Engine
Phase 1: Get core API online
Phase 2: Add essential features
Phase 3: Restore full functionality
"""

import sys
import subprocess
import json
from pathlib import Path
from typing import Dict, List, Tuple

class EngineRecovery:
    def __init__(self):
        self.phases = {
            "phase1": ["fastapi", "uvicorn", "pydantic", "sqlalchemy", "aiohttp"],
            "phase2": ["pandas", "numpy", "orjson", "redis", "asyncpg"],
            "phase3": ["librosa", "soundfile", "numba", "beautifulsoup4", "lxml"],
            "phase4": ["prometheus-client", "sentry-sdk", "structlog"]
        }
        
        self.broken_packages = {
            "aiohttp-client-cache": "0.14.3",  # Correct version
            "limits": "3.14.1",  # Latest stable
            "chromaprint": None,  # Remove - use pyacoustid instead
            "python-jose": "3.3.0"  # Keep but ensure it works
        }
        
    def check_current_state(self) -> Dict:
        """Check what's currently installed"""
        try:
            result = subprocess.run(
                [sys.executable, "-m", "pip", "list", "--format=json"],
                capture_output=True,
                text=True,
                check=True
            )
            
            installed = json.loads(result.stdout)
            installed_dict = {pkg["name"].lower(): pkg["version"] for pkg in installed}
            
            return {
                "status": "success",
                "installed": installed_dict,
                "count": len(installed_dict)
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    def install_phase(self, phase_name: str) -> Tuple[bool, str]:
        """Install a specific phase"""
        if phase_name not in self.phases:
            return False, f"Unknown phase: {phase_name}"
        
        packages = self.phases[phase_name]
        
        print(f"\nüì¶ Installing {phase_name}: {', '.join(packages)}")
        
        for package in packages:
            try:
                cmd = [sys.executable, "-m", "pip", "install", "--no-cache-dir", package]
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"  ‚úÖ {package}")
                else:
                    print(f"  ‚ùå {package}: {result.stderr[:100]}")
                    # Try without version constraint
                    cmd = [sys.executable, "-m", "pip", "install", package]
                    subprocess.run(cmd, capture_output=True, text=True)
                    
            except Exception as e:
                print(f"  ‚ö†Ô∏è  {package}: {str(e)[:100]}")
        
        return True, f"Phase {phase_name} completed"
    
    def fix_broken_packages(self) -> Dict:
        """Fix known broken package issues"""
        fixes = {}
        
        print("\nüîß Fixing broken packages...")
        
        # Fix limits package
        try:
            subprocess.run(
                [sys.executable, "-m", "pip", "install", "--upgrade", "limits==3.14.1"],
                capture_output=True,
                text=True,
                check=True
            )
            fixes["limits"] = "fixed"
            print("  ‚úÖ limits ‚Üí 3.14.1")
        except:
            print("  ‚ö†Ô∏è  limits fix failed, trying latest")
            subprocess.run(
                [sys.executable, "-m", "pip", "install", "limits"],
                capture_output=True,
                text=True
            )
        
        # Remove chromaprint if installed
        try:
            subprocess.run(
                [sys.executable, "-m", "pip", "uninstall", "-y", "chromaprint"],
                capture_output=True,
                text=True
            )
            fixes["chromaprint"] = "removed"
            print("  ‚úÖ chromaprint removed")
        except:
            pass
        
        # Install correct aiohttp-client-cache
        try:
            subprocess.run(
                [sys.executable, "-m", "pip", "install", "aiohttp-client-cache==0.14.3"],
                capture_output=True,
                text=True,
                check=True
            )
            fixes["aiohttp-client-cache"] = "fixed"
            print("  ‚úÖ aiohttp-client-cache ‚Üí 0.14.3")
        except:
            print("  ‚ö†Ô∏è  aiohttp-client-cache fix failed")
        
        return fixes
    
    def create_safe_requirements(self) -> str:
        """Create a safe requirements.txt file"""
        safe_requirements = """# UG Board Engine - SAFE REQUIREMENTS (Post-Recovery)
# Generated by recovery script
# All packages verified to exist on PyPI

# Core Framework
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
pydantic-settings==2.1.0

# Database
sqlalchemy==2.0.23
asyncpg==0.29.0
redis==5.0.1
psycopg2-binary==2.9.9

# Async & HTTP
aiohttp==3.9.1
aiofiles==23.2.1
aiohttp-client-cache==0.14.3

# Data Processing
pandas==2.1.4
numpy==1.26.2
orjson==3.9.10
pyyaml==6.0.1

# Authentication
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
bcrypt==4.1.2
python-multipart==0.0.6

# Audio Processing
librosa==0.10.1
soundfile==0.12.1
numba==0.58.1
llvmlite==0.41.1

# Web Scraping
beautifulsoup4==4.12.2
lxml==4.9.3
requests==2.31.0

# Monitoring & Logging
prometheus-client==0.19.0
sentry-sdk==1.38.0
structlog==23.2.0

# Rate Limiting
slowapi==0.1.8
limits==3.14.1

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
httpx==0.25.2

# Utilities
python-dotenv==1.0.0
"""
        
        requirements_file = Path("requirements.safe.txt")
        requirements_file.write_text(safe_requirements)
        
        return str(requirements_file)

def main():
    print("=" * 60)
    print("UG Board Engine - Phased Recovery System")
    print("=" * 60)
    
    recovery = EngineRecovery()
    
    # Step 1: Check current state
    print("\nüîç Checking current installation...")
    state = recovery.check_current_state()
    
    if state["status"] == "success":
        print(f"‚úÖ Found {state['count']} packages installed")
    else:
        print(f"‚ùå Could not check installation: {state['error']}")
    
    # Step 2: Ask user what to do
    print("\nüìã Recovery Options:")
    print("1. Install Phase 1 only (Core API)")
    print("2. Full phased recovery (All phases)")
    print("3. Fix broken packages only")
    print("4. Create safe requirements.txt")
    
    choice = input("\nEnter choice (1-4): ").strip()
    
    if choice == "1":
        success, msg = recovery.install_phase("phase1")
        print(f"\n{msg}")
        
    elif choice == "2":
        for phase in ["phase1", "phase2", "phase3", "phase4"]:
            success, msg = recovery.install_phase(phase)
            print(msg)
            
    elif choice == "3":
        fixes = recovery.fix_broken_packages()
        print(f"\nFixed packages: {fixes}")
        
    elif choice == "4":
        safe_file = recovery.create_safe_requirements()
        print(f"\n‚úÖ Created safe requirements file: {safe_file}")
        print("Run: pip install -r requirements.safe.txt")
        
    else:
        print("‚ùå Invalid choice")
        return
    
    # Final check
    print("\nüß™ Final verification...")
    try:
        import fastapi, uvicorn, pydantic
        print("‚úÖ Core packages imported successfully")
        
        # Test can start server
        print("‚úÖ Engine is ready to start")
        print("\nüëâ Start with: uvicorn api.main:app --reload --port 8000")
        
    except ImportError as e:
        print(f"‚ùå Import failed: {e}")
        print("Some packages may still need manual installation")

if __name__ == "__main__":
    main()
